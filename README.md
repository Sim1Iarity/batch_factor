# batch_factor
Batch factorization &amp; primality testing

## Intro to Implementation
The file [batch.cpp](/batch.cpp) uses the GMP library to compute the GCD of inputs with a large primorial. This program uses 20 threads.

The file [primorial.cpp](/primorial.cpp) outputs the primorial of the input into a file in `mpz_out_raw` format. This program uses 20 threads.

The file [sort_proof.cpp](/sort_proof.cpp) parses an input file that contains expressions to be sorted and tested primality. This program uses 20 threads.

**Warning: before the first call to `batch.cpp`, at least one file has to be generated by `primorial.cpp`, and `batch.cpp` must be changed corresponding to the location of the primorial file.**

## Current Limitations (Todo List)
1. These C++ files has to be compiled manually, and currently no script is doing this automatically.
2. `sort_proof.cpp` have to be executed after `batch.cpp`. In future versions, `sort_proof.cpp` will be integrated into `batch.cpp`.
3. Only a few types of input is supported for `batch.cpp` (see below).

## Libraries used
* The GNU Multiprecision (GMP) Library
* The Pari/GP Library
* The Elliptic Curve Factorization Method (ECM) Library
* George Woltman's GWNUM Library

## Inputs to `batch.cpp`
### Currently supported expressions
1. `(k1-k2)*b^n+c`
2. `k*(b1-b2)^n+c`
3. `k*b^(n1-n2)+c`
4. `k*b^n+(c1-c2)`
In the above four expressions, all `+c` can be replaced by `-c`.
### Not supported expressions
5. `(k1-k2)*b!+c`
6. `k*(b1-b2)!+c`
7. `k*b!+(c1-c2)`
8. `(k1-k2)*b#+c`
9. `k*(b1-b2)#+c`
10. `k*b!+(c1-c2)`
11. `Phi((k1-k2),b)`
12. `Phi(k,(b1-b2))`
13. `(k1-k2)*I(b)+c`
14. `k*I(b1-b2)+c`
15. `k*I(b)+(c1-c2)`
16. `(k1-k2)*lucas(b)+c`
17. `k*lucas(b1-b2)+c`
18. `k*lucas(b)+(c1-c2)`
### Notes
For `k*b^n+c`, there aren't special optimizations for $k=1$ and $c=\pm1$. #n and !n are not supported.
